# JetpackComposeEssentials
Learning about Jetpack Compose Essentials


Many of the advantages of Compose originate from the fact that is both DECLARATIVE and DATA-DRIVEN. 

## Development before Compose
To understand the meaning and advantages of the Compose declarative syntax, it helps to understand how user interface layouts were designed before the introduction of Compose. Previously, Android apps were still built entirely using Android Studio together with a collection of associated frameworks that make up the Android Development Kit. 

## Compose declarative syntax
Compose introduces a declarative syntax that provides an entirely different way of implementing user interface layouts and behavior from the Layout Editor approach. Instead of manually designing the intricate details of the layout and appearance of components that make up a scene, Compose allows the scenes to be described using a simple and intuitive syntax. In other words, Compose allows layouts to be created by declaring how the user interface should appear without having to worry about the complexity of how the layout is built. 

Compose declarations are structured hierarchically, which also makes it easy to create complex views by composing together small, re-usable custom sub-views. While a layout is being declared and tested, Android Studio provides a preview canvas that changes in real-time to reflect the appearance of the layout. Android Studio also includes an _interactive preview_ mode which allows the app to be launched within the preview canvas and fully tested without the need to build and run on a simulator or device. 

## Compose is data-driven
When we say that Compose is data-driven, this is not to say that it is no longer necessary to handle events generated by the user (in other words the interaction between the user and the app user interface). It is still necessary, for example, to know when the user taps a button or moves a slider and to react in some app-specific way.
**Being data-driven relates more to the relationship between the underlying app data and the user interface and logic of the app.** Before the introduction of Compose, an Android app would contain code responsible for checking the current values of data within the app. If data was likely to change over time, code had to be written to ensure that the user interface always reflected the latest state of the data (perhaps by writing code to frequently check for changes to the data, or by providing a refresh option for the user to request a data update). Similar challenges arise when keeping the user interface state consistent and making sure issues like toggle button settings are stored appropriately. Requirements such as these can become increasingly complex when multiple areas of an app DEPEND ON THE SAME DATA SOURCES. 
**Compose addresses this complexity by providing a system that is based on STATE. Data that is stored as state ensures that any changes to that data are automatically reflected in the user interface without the need to write any additional code to detect the change. Any user interface component that accesses a state is essentially SUBSCRIBED TO THAT STATE. WHEN THE STATE IS CHANGED ANYWHERE IN THE APP CODE, ANY SUBSCRIBER COMPONENTS TO THAT DATA WILL BE DESTROYED AND RECREATED TO REFLECT THE DATA CHANGE IN A PROCESS CALLED RECOMPOSITION. THIS ENSURES THAT WHEN ANY STATE ON WHICH THE USER INTERACE IS DEPENDENT CHANGES, ALL COMPONENTS THAT RELY ON THAT DATA WILL AUTOMATICALLY UPDATE TO REFLECT THE LATEST STATE.**

# Composable Functions Overview

